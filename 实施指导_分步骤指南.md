# LLB (çˆ±å­¦ä¼´) å®æ–½æŒ‡å¯¼ - åˆ†æ­¥éª¤æŒ‡å—

## ğŸ“‹ é¡¹ç›®å®Œæˆè·¯çº¿å›¾

---

## ğŸ¯ å½“å‰é¡¹ç›®çŠ¶æ€æ€»ç»“

### âœ… å·²å®Œæˆçš„æ ¸å¿ƒåŠŸèƒ½
1. **AIå¼•æ“**: Google Gemma 3 1Bæ¨¡å‹é›†æˆå®Œæˆ
2. **åç«¯API**: FastAPIæœåŠ¡å™¨è¿è¡Œæ­£å¸¸ (http://localhost:8000)
3. **æ™ºèƒ½æç¤ºç³»ç»Ÿ**: 7ä¸ªè¯é¢˜åˆ†ç±»çš„æç¤ºå·¥ç¨‹å®Œæˆ
4. **å¤šè¯­è¨€æ”¯æŒ**: ä¸­æ–‡ã€æ²³å—æ–¹è¨€ã€è‹±æ–‡è¯†åˆ«
5. **å®‰å…¨è¿‡æ»¤**: å†…å®¹å®‰å…¨æ£€æŸ¥æœºåˆ¶
6. **è¯­éŸ³å¤„ç†**: Whisperè¯­éŸ³è½¬æ–‡å­—é›†æˆ
7. **æ–‡æ¡£å¤„ç†**: PDFä¸Šä¼ å’Œåˆ†æåŠŸèƒ½

### ğŸ”„ è¿›è¡Œä¸­çš„åŠŸèƒ½
1. **å‰ç«¯ç•Œé¢**: Reactç»„ä»¶å¼€å‘
2. **ç”¨æˆ·ä½“éªŒ**: ç•Œé¢ä¼˜åŒ–å’Œäº¤äº’è®¾è®¡
3. **æ€§èƒ½ä¼˜åŒ–**: GPUåŠ é€Ÿå’Œå†…å­˜ç®¡ç†

### ğŸ“‹ å¾…å®Œæˆçš„åŠŸèƒ½
1. **å‰åç«¯è¿æ¥**: APIé›†æˆåˆ°å‰ç«¯ç•Œé¢
2. **è¯­éŸ³ç•Œé¢**: è¯­éŸ³è¾“å…¥æŒ‰é’®å’Œå®æ—¶å¤„ç†
3. **æ–‡æ¡£ä¸Šä¼ ç•Œé¢**: æ‹–æ‹½ä¸Šä¼ å’Œè¿›åº¦æ˜¾ç¤º
4. **å¤šè¯­è¨€ç•Œé¢**: ä¸­è‹±æ–‡ç•Œé¢åˆ‡æ¢
5. **éƒ¨ç½²ä¼˜åŒ–**: ç”Ÿäº§ç¯å¢ƒé…ç½®

---

## ğŸš€ è¯¦ç»†å®æ–½æ­¥éª¤

### ç¬¬ä¸€æ­¥ï¼šéªŒè¯å½“å‰ç³»ç»ŸçŠ¶æ€

#### 1.1 æ£€æŸ¥åç«¯æœåŠ¡
```bash
# æ£€æŸ¥åç«¯æ˜¯å¦è¿è¡Œ
curl http://localhost:8000/health

# é¢„æœŸè¿”å›ï¼š
{
  "status": "healthy",
  "version": "1.0.0",
  "model_loaded": true,
  "supported_languages": ["en", "zh-CN", "zh-CN-henan"],
  "available_topics": ["basic_education", "safety", "contraception", "anatomy", "relationship", "sti", "consent"]
}
```

#### 1.2 æµ‹è¯•AIå¯¹è¯åŠŸèƒ½
```bash
# æµ‹è¯•ä¸­æ–‡å¯¹è¯
curl -X POST http://localhost:8000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "ä»€ä¹ˆæ˜¯æ€§å¥åº·ï¼Ÿ", "language": "zh-CN"}'

# æµ‹è¯•è‹±æ–‡å¯¹è¯
curl -X POST http://localhost:8000/api/chat \
  -H "Content-Type: application/json" \
  -d '{"message": "What is sexual health?", "language": "en"}'
```

#### 1.3 æ£€æŸ¥å‰ç«¯å¼€å‘ç¯å¢ƒ
```bash
# è¿›å…¥å‰ç«¯ç›®å½•
cd frontend

# æ£€æŸ¥ä¾èµ–æ˜¯å¦å®‰è£…
npm list

# å¯åŠ¨å¼€å‘æœåŠ¡å™¨
npm run dev
```

### ç¬¬äºŒæ­¥ï¼šå®Œå–„å‰ç«¯ç”¨æˆ·ç•Œé¢

#### 2.1 åˆ›å»ºä¸»è¦ç»„ä»¶

**èŠå¤©ç•Œé¢ç»„ä»¶** (`frontend/src/components/ChatInterface.tsx`):
```typescript
import React, { useState, useRef } from 'react';
import { 
  Box, 
  TextField, 
  Button, 
  Paper, 
  Typography,
  IconButton,
  CircularProgress 
} from '@mui/material';
import { Mic, Send, Upload } from '@mui/icons-material';

interface Message {
  id: string;
  content: string;
  sender: 'user' | 'ai';
  timestamp: Date;
  language?: string;
  topic?: string;
}

export const ChatInterface: React.FC = () => {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputText, setInputText] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  
  const handleSendMessage = async () => {
    if (!inputText.trim()) return;
    
    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
    const userMessage: Message = {
      id: Date.now().toString(),
      content: inputText,
      sender: 'user',
      timestamp: new Date()
    };
    setMessages(prev => [...prev, userMessage]);
    
    setIsLoading(true);
    try {
      // è°ƒç”¨åç«¯API
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: inputText })
      });
      
      const data = await response.json();
      
      // æ·»åŠ AIå›å¤
      const aiMessage: Message = {
        id: (Date.now() + 1).toString(),
        content: data.response,
        sender: 'ai',
        timestamp: new Date(),
        language: data.language_detected,
        topic: data.topic
      };
      setMessages(prev => [...prev, aiMessage]);
      
    } catch (error) {
      console.error('å‘é€æ¶ˆæ¯å¤±è´¥:', error);
    } finally {
      setIsLoading(false);
      setInputText('');
    }
  };
  
  return (
    <Box sx={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* æ¶ˆæ¯æ˜¾ç¤ºåŒºåŸŸ */}
      <Box sx={{ flex: 1, overflow: 'auto', p: 2 }}>
        {messages.map(message => (
          <Paper 
            key={message.id}
            sx={{ 
              p: 2, 
              mb: 1, 
              ml: message.sender === 'user' ? 4 : 0,
              mr: message.sender === 'ai' ? 4 : 0,
              bgcolor: message.sender === 'user' ? 'primary.light' : 'grey.100'
            }}
          >
            <Typography>{message.content}</Typography>
            {message.topic && (
              <Typography variant="caption" color="textSecondary">
                è¯é¢˜: {message.topic}
              </Typography>
            )}
          </Paper>
        ))}
        {isLoading && <CircularProgress />}
      </Box>
      
      {/* è¾“å…¥åŒºåŸŸ */}
      <Box sx={{ p: 2, borderTop: 1, borderColor: 'divider' }}>
        <Box sx={{ display: 'flex', gap: 1 }}>
          <TextField
            fullWidth
            value={inputText}
            onChange={(e) => setInputText(e.target.value)}
            placeholder="è¯·è¾“å…¥æ‚¨çš„é—®é¢˜..."
            onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
          />
          <IconButton color="primary">
            <Mic />
          </IconButton>
          <IconButton color="primary">
            <Upload />
          </IconButton>
          <Button 
            variant="contained" 
            onClick={handleSendMessage}
            disabled={!inputText.trim() || isLoading}
          >
            <Send />
          </Button>
        </Box>
      </Box>
    </Box>
  );
};
```

#### 2.2 è¯­éŸ³è¾“å…¥ç»„ä»¶

**è¯­éŸ³å½•åˆ¶ç»„ä»¶** (`frontend/src/components/VoiceInput.tsx`):
```typescript
import React, { useState, useRef } from 'react';
import { IconButton, Tooltip } from '@mui/material';
import { Mic, MicOff } from '@mui/icons-material';

interface VoiceInputProps {
  onTranscript: (text: string) => void;
  disabled?: boolean;
}

export const VoiceInput: React.FC<VoiceInputProps> = ({ 
  onTranscript, 
  disabled = false 
}) => {
  const [isRecording, setIsRecording] = useState(false);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const chunksRef = useRef<Blob[]>([]);
  
  const startRecording = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      chunksRef.current = [];
      
      mediaRecorder.ondataavailable = (event) => {
        chunksRef.current.push(event.data);
      };
      
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(chunksRef.current, { type: 'audio/wav' });
        await sendAudioToServer(audioBlob);
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start();
      setIsRecording(true);
    } catch (error) {
      console.error('å½•éŸ³å¤±è´¥:', error);
    }
  };
  
  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  };
  
  const sendAudioToServer = async (audioBlob: Blob) => {
    const formData = new FormData();
    formData.append('audio', audioBlob, 'recording.wav');
    
    try {
      const response = await fetch('/api/voice', {
        method: 'POST',
        body: formData
      });
      
      const data = await response.json();
      if (data.transcript) {
        onTranscript(data.transcript);
      }
    } catch (error) {
      console.error('è¯­éŸ³è½¬æ–‡å­—å¤±è´¥:', error);
    }
  };
  
  return (
    <Tooltip title={isRecording ? "åœæ­¢å½•éŸ³" : "å¼€å§‹å½•éŸ³"}>
      <IconButton
        color={isRecording ? "secondary" : "primary"}
        onClick={isRecording ? stopRecording : startRecording}
        disabled={disabled}
      >
        {isRecording ? <MicOff /> : <Mic />}
      </IconButton>
    </Tooltip>
  );
};
```

#### 2.3 æ–‡æ¡£ä¸Šä¼ ç»„ä»¶

**æ–‡æ¡£ä¸Šä¼ ç»„ä»¶** (`frontend/src/components/DocumentUpload.tsx`):
```typescript
import React, { useState } from 'react';
import { 
  Box, 
  Button, 
  Typography, 
  LinearProgress,
  Alert 
} from '@mui/material';
import { Upload } from '@mui/icons-material';

interface DocumentUploadProps {
  onAnalysisComplete: (analysis: string) => void;
}

export const DocumentUpload: React.FC<DocumentUploadProps> = ({ 
  onAnalysisComplete 
}) => {
  const [uploading, setUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  
  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    
    // æ£€æŸ¥æ–‡ä»¶ç±»å‹å’Œå¤§å°
    if (file.type !== 'application/pdf') {
      setError('åªæ”¯æŒPDFæ–‡ä»¶');
      return;
    }
    
    if (file.size > 20 * 1024 * 1024) { // 20MB
      setError('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡20MB');
      return;
    }
    
    setUploading(true);
    setError(null);
    setProgress(0);
    
    const formData = new FormData();
    formData.append('document', file);
    
    try {
      const response = await fetch('/api/document', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error('ä¸Šä¼ å¤±è´¥');
      }
      
      const data = await response.json();
      onAnalysisComplete(data.analysis);
      
    } catch (error) {
      setError('æ–‡æ¡£åˆ†æå¤±è´¥ï¼Œè¯·é‡è¯•');
      console.error('æ–‡æ¡£ä¸Šä¼ å¤±è´¥:', error);
    } finally {
      setUploading(false);
      setProgress(0);
    }
  };
  
  return (
    <Box sx={{ p: 2 }}>
      <input
        accept=".pdf"
        style={{ display: 'none' }}
        id="document-upload"
        type="file"
        onChange={handleFileUpload}
        disabled={uploading}
      />
      <label htmlFor="document-upload">
        <Button
          variant="outlined"
          component="span"
          startIcon={<Upload />}
          disabled={uploading}
          fullWidth
        >
          {uploading ? 'åˆ†æä¸­...' : 'ä¸Šä¼ PDFæ–‡æ¡£'}
        </Button>
      </label>
      
      {uploading && (
        <Box sx={{ mt: 2 }}>
          <LinearProgress variant="indeterminate" />
          <Typography variant="caption" color="textSecondary">
            æ­£åœ¨åˆ†ææ–‡æ¡£å†…å®¹...
          </Typography>
        </Box>
      )}
      
      {error && (
        <Alert severity="error" sx={{ mt: 2 }}>
          {error}
        </Alert>
      )}
    </Box>
  );
};
```

### ç¬¬ä¸‰æ­¥ï¼šé›†æˆå¤šè¯­è¨€æ”¯æŒ

#### 3.1 é…ç½®å›½é™…åŒ–

**åˆ›å»ºè¯­è¨€é…ç½®** (`frontend/src/i18n/index.ts`):
```typescript
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

const resources = {
  en: {
    translation: {
      "app_title": "LLB - Sexual Health Education",
      "chat_placeholder": "Ask your question...",
      "send_button": "Send",
      "voice_input": "Voice Input",
      "upload_document": "Upload Document",
      "language_switch": "Language",
      "topics": {
        "basic_education": "Basic Education",
        "safety": "Safety",
        "contraception": "Contraception",
        "anatomy": "Anatomy",
        "relationship": "Relationships",
        "sti": "STI Prevention",
        "consent": "Consent"
      }
    }
  },
  "zh-CN": {
    translation: {
      "app_title": "çˆ±å­¦ä¼´ - æ€§å¥åº·æ•™è‚²",
      "chat_placeholder": "è¯·è¾“å…¥æ‚¨çš„é—®é¢˜...",
      "send_button": "å‘é€",
      "voice_input": "è¯­éŸ³è¾“å…¥",
      "upload_document": "ä¸Šä¼ æ–‡æ¡£",
      "language_switch": "è¯­è¨€",
      "topics": {
        "basic_education": "åŸºç¡€æ•™è‚²",
        "safety": "å®‰å…¨é˜²æŠ¤",
        "contraception": "é¿å­•çŸ¥è¯†",
        "anatomy": "ç”Ÿç†è§£å‰–",
        "relationship": "å…³ç³»å¥åº·",
        "sti": "ç–¾ç—…é¢„é˜²",
        "consent": "åŒæ„æ•™è‚²"
      }
    }
  }
};

i18n
  .use(initReactI18next)
  .init({
    resources,
    lng: 'zh-CN', // é»˜è®¤ä¸­æ–‡
    fallbackLng: 'en',
    interpolation: {
      escapeValue: false
    }
  });

export default i18n;
```

#### 3.2 è¯­è¨€åˆ‡æ¢ç»„ä»¶

**è¯­è¨€é€‰æ‹©å™¨** (`frontend/src/components/LanguageSelector.tsx`):
```typescript
import React from 'react';
import { Select, MenuItem, FormControl, InputLabel } from '@mui/material';
import { useTranslation } from 'react-i18next';

export const LanguageSelector: React.FC = () => {
  const { i18n, t } = useTranslation();
  
  const handleLanguageChange = (language: string) => {
    i18n.changeLanguage(language);
    localStorage.setItem('preferred_language', language);
  };
  
  return (
    <FormControl size="small" sx={{ minWidth: 120 }}>
      <InputLabel>{t('language_switch')}</InputLabel>
      <Select
        value={i18n.language}
        onChange={(e) => handleLanguageChange(e.target.value)}
        label={t('language_switch')}
      >
        <MenuItem value="zh-CN">ä¸­æ–‡</MenuItem>
        <MenuItem value="en">English</MenuItem>
      </Select>
    </FormControl>
  );
};
```

### ç¬¬å››æ­¥ï¼šä¼˜åŒ–AIå“åº”è´¨é‡

#### 4.1 å¢å¼ºæç¤ºæ¨¡æ¿

**æ›´æ–°æ€§å¥åº·æç¤º** (`ai/prompts/sexual_health.py`):
```python
# æ·»åŠ æ›´å¤šæ–‡åŒ–æ•æ„Ÿçš„æç¤ºæ¨¡æ¿
CHINESE_CULTURAL_PROMPTS = {
    "family_planning": """
    ä½œä¸ºä¸€ä¸ªä¸“ä¸šçš„æ€§å¥åº·æ•™è‚²åŠ©æ‰‹ï¼Œè¯·ä»¥é€‚åˆä¸­å›½æ–‡åŒ–èƒŒæ™¯çš„æ–¹å¼å›ç­”å…³äºè®¡åˆ’ç”Ÿè‚²çš„é—®é¢˜ã€‚
    
    è¦æ±‚ï¼š
    1. å°Šé‡ä¸­å›½ä¼ ç»Ÿå®¶åº­è§‚å¿µ
    2. æä¾›ç§‘å­¦å‡†ç¡®çš„åŒ»å­¦ä¿¡æ¯
    3. è€ƒè™‘ä¸­å›½çš„è®¡åˆ’ç”Ÿè‚²æ”¿ç­–èƒŒæ™¯
    4. ä½¿ç”¨æ¸©å’Œã€ä¸“ä¸šçš„è¯­è¨€
    5. é¿å…è¿‡äºç›´ç™½çš„è¡¨è¾¾
    
    ç”¨æˆ·é—®é¢˜ï¼š{user_question}
    
    è¯·æä¾›ä¸€ä¸ªæ•™è‚²æ€§ã€ç§‘å­¦æ€§ã€æ–‡åŒ–é€‚å®œçš„å›ç­”ï¼š
    """,
    
    "youth_education": """
    ä½œä¸ºé’å°‘å¹´æ€§å¥åº·æ•™è‚²ä¸“å®¶ï¼Œè¯·ä¸ºä¸­å›½é’å°‘å¹´æä¾›é€‚é¾„çš„æ€§å¥åº·æ•™è‚²å†…å®¹ã€‚
    
    æŒ‡å¯¼åŸåˆ™ï¼š
    1. å†…å®¹é€‚åˆé’å°‘å¹´ç†è§£æ°´å¹³
    2. å¼ºè°ƒå¥åº·å’Œå®‰å…¨
    3. å°Šé‡ä¸­å›½æ•™è‚²ç¯å¢ƒ
    4. é¼“åŠ±ä¸å®¶é•¿å’Œè€å¸ˆæ²Ÿé€š
    5. æä¾›æ­£é¢çš„ä»·å€¼å¼•å¯¼
    
    é—®é¢˜ï¼š{user_question}
    
    å›ç­”ï¼š
    """
}
```

#### 4.2 æ”¹è¿›å®‰å…¨è¿‡æ»¤

**å¢å¼ºå®‰å…¨æ£€æŸ¥** (`ai/safety/content_filter.py`):
```python
class ContentSafetyFilter:
    """å†…å®¹å®‰å…¨è¿‡æ»¤å™¨"""
    
    def __init__(self):
        self.inappropriate_patterns = [
            # ä¸å½“å†…å®¹æ¨¡å¼
            r'è‰²æƒ…|æ·«ç§½|ä¸‹æµ',
            r'æš´åŠ›|ä¼¤å®³|è‡ªæ®‹',
            r'æ­§è§†|ä»‡æ¨|åè§'
        ]
        
        self.educational_keywords = [
            # æ•™è‚²å…³é”®è¯
            'å¥åº·', 'æ•™è‚²', 'ç§‘å­¦', 'åŒ»å­¦', 'é¢„é˜²',
            'health', 'education', 'medical', 'prevention'
        ]
    
    def is_educational_content(self, text: str) -> bool:
        """åˆ¤æ–­æ˜¯å¦ä¸ºæ•™è‚²å†…å®¹"""
        educational_score = 0
        for keyword in self.educational_keywords:
            if keyword in text.lower():
                educational_score += 1
        
        return educational_score >= 2
    
    def check_safety(self, text: str) -> dict:
        """æ£€æŸ¥å†…å®¹å®‰å…¨æ€§"""
        result = {
            'is_safe': True,
            'is_educational': self.is_educational_content(text),
            'warnings': []
        }
        
        for pattern in self.inappropriate_patterns:
            if re.search(pattern, text, re.IGNORECASE):
                result['is_safe'] = False
                result['warnings'].append(f'æ£€æµ‹åˆ°ä¸å½“å†…å®¹: {pattern}')
        
        return result
```

### ç¬¬äº”æ­¥ï¼šæ€§èƒ½ä¼˜åŒ–

#### 5.1 GPUå†…å­˜ä¼˜åŒ–

**ä¼˜åŒ–æ¨¡å‹åŠ è½½** (`ai/model_optimizer.py`):
```python
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer

class ModelOptimizer:
    """æ¨¡å‹æ€§èƒ½ä¼˜åŒ–å™¨"""
    
    @staticmethod
    def load_optimized_model(model_path: str, device: str = "cuda"):
        """åŠ è½½ä¼˜åŒ–çš„æ¨¡å‹"""
        
        # æ£€æŸ¥å¯ç”¨æ˜¾å­˜
        if torch.cuda.is_available():
            gpu_memory = torch.cuda.get_device_properties(0).total_memory
            gpu_memory_gb = gpu_memory / (1024**3)
            
            if gpu_memory_gb >= 12:  # RTX 3060 12GB
                # ä½¿ç”¨4ä½é‡åŒ–èŠ‚çœæ˜¾å­˜
                model = AutoModelForCausalLM.from_pretrained(
                    model_path,
                    torch_dtype=torch.float16,
                    device_map="auto",
                    load_in_4bit=True,
                    bnb_4bit_compute_dtype=torch.float16
                )
            else:
                # ä½¿ç”¨CPUå¸è½½
                model = AutoModelForCausalLM.from_pretrained(
                    model_path,
                    torch_dtype=torch.float16,
                    device_map="auto",
                    offload_folder="./offload"
                )
        else:
            # CPUæ¨¡å¼
            model = AutoModelForCausalLM.from_pretrained(
                model_path,
                torch_dtype=torch.float32
            )
        
        tokenizer = AutoTokenizer.from_pretrained(model_path)
        return model, tokenizer
```

#### 5.2 å“åº”ç¼“å­˜

**å®ç°æ™ºèƒ½ç¼“å­˜** (`backend/services/cache_service.py`):
```python
import hashlib
import json
from typing import Optional, Dict, Any
from datetime import datetime, timedelta

class ResponseCache:
    """AIå“åº”ç¼“å­˜æœåŠ¡"""
    
    def __init__(self, cache_duration_hours: int = 24):
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.cache_duration = timedelta(hours=cache_duration_hours)
    
    def _generate_key(self, question: str, language: str) -> str:
        """ç”Ÿæˆç¼“å­˜é”®"""
        content = f"{question.lower().strip()}_{language}"
        return hashlib.md5(content.encode()).hexdigest()
    
    def get_cached_response(self, question: str, language: str) -> Optional[str]:
        """è·å–ç¼“å­˜çš„å“åº”"""
        key = self._generate_key(question, language)
        
        if key in self.cache:
            cached_item = self.cache[key]
            if datetime.now() - cached_item['timestamp'] < self.cache_duration:
                return cached_item['response']
            else:
                # ç¼“å­˜è¿‡æœŸï¼Œåˆ é™¤
                del self.cache[key]
        
        return None
    
    def cache_response(self, question: str, language: str, response: str):
        """ç¼“å­˜å“åº”"""
        key = self._generate_key(question, language)
        self.cache[key] = {
            'response': response,
            'timestamp': datetime.now()
        }
    
    def clear_expired_cache(self):
        """æ¸…ç†è¿‡æœŸç¼“å­˜"""
        current_time = datetime.now()
        expired_keys = [
            key for key, item in self.cache.items()
            if current_time - item['timestamp'] > self.cache_duration
        ]
        
        for key in expired_keys:
            del self.cache[key]
```

### ç¬¬å…­æ­¥ï¼šéƒ¨ç½²å’Œæµ‹è¯•

#### 6.1 ç”Ÿäº§ç¯å¢ƒé…ç½®

**Dockeré…ç½®** (`docker-compose.prod.yml`):
```yaml
version: '3.8'

services:
  llb-backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - LLB_ENVIRONMENT=production
      - LLB_DEBUG=false
    volumes:
      - ./ai/models:/app/ai/models:ro
      - ./logs:/app/logs
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]

  llb-frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    depends_on:
      - llb-backend
    environment:
      - NODE_ENV=production
      - REACT_APP_API_URL=http://localhost:8000

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - llb-frontend
      - llb-backend
```

#### 6.2 è‡ªåŠ¨åŒ–æµ‹è¯•

**ç«¯åˆ°ç«¯æµ‹è¯•** (`tests/e2e/test_full_workflow.py`):
```python
import pytest
import requests
import time

class TestFullWorkflow:
    """å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•"""
    
    BASE_URL = "http://localhost:8000"
    
    def test_health_check(self):
        """æµ‹è¯•å¥åº·æ£€æŸ¥"""
        response = requests.get(f"{self.BASE_URL}/health")
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "healthy"
        assert data["model_loaded"] is True
    
    def test_chinese_conversation(self):
        """æµ‹è¯•ä¸­æ–‡å¯¹è¯"""
        payload = {
            "message": "ä»€ä¹ˆæ˜¯å®‰å…¨å¥—ï¼Ÿ",
            "language": "zh-CN"
        }
        response = requests.post(f"{self.BASE_URL}/api/chat", json=payload)
        assert response.status_code == 200
        data = response.json()
        assert "response" in data
        assert data["language_detected"] == "zh-CN"
        assert len(data["response"]) > 50  # ç¡®ä¿å›å¤æœ‰è¶³å¤Ÿå†…å®¹
    
    def test_english_conversation(self):
        """æµ‹è¯•è‹±æ–‡å¯¹è¯"""
        payload = {
            "message": "What is contraception?",
            "language": "en"
        }
        response = requests.post(f"{self.BASE_URL}/api/chat", json=payload)
        assert response.status_code == 200
        data = response.json()
        assert "response" in data
        assert data["language_detected"] == "en"
    
    def test_topic_classification(self):
        """æµ‹è¯•è¯é¢˜åˆ†ç±»"""
        test_cases = [
            ("é¿å­•å¥—æ€ä¹ˆä½¿ç”¨", "contraception"),
            ("ä»€ä¹ˆæ˜¯æ€§åŒæ„", "consent"),
            ("é’æ˜¥æœŸå‘è‚²", "anatomy"),
            ("æ€§ç—…é¢„é˜²", "sti")
        ]
        
        for question, expected_topic in test_cases:
            payload = {"message": question, "language": "zh-CN"}
            response = requests.post(f"{self.BASE_URL}/api/chat", json=payload)
            data = response.json()
            assert data["topic"] == expected_topic
    
    def test_safety_filtering(self):
        """æµ‹è¯•å®‰å…¨è¿‡æ»¤"""
        inappropriate_messages = [
            "è‰²æƒ…å†…å®¹",
            "æš´åŠ›å†…å®¹",
            "æœ‰å®³å»ºè®®"
        ]
        
        for message in inappropriate_messages:
            payload = {"message": message, "language": "zh-CN"}
            response = requests.post(f"{self.BASE_URL}/api/chat", json=payload)
            data = response.json()
            # åº”è¯¥æœ‰å®‰å…¨æ ‡è®°æˆ–æ‹’ç»å›å¤
            assert len(data.get("safety_flags", [])) > 0 or "ä¸èƒ½" in data["response"]
```

### ç¬¬ä¸ƒæ­¥ï¼šç”¨æˆ·æ–‡æ¡£å’ŒåŸ¹è®­

#### 7.1 ç”¨æˆ·æ‰‹å†Œ

**åˆ›å»ºç”¨æˆ·æŒ‡å—** (`docs/user_guide_zh.md`):
```markdown
# çˆ±å­¦ä¼´ (LLB) ç”¨æˆ·æŒ‡å—

## å¿«é€Ÿå¼€å§‹

### 1. æ–‡å­—å¯¹è¯
- åœ¨è¾“å…¥æ¡†ä¸­è¾“å…¥æ‚¨çš„é—®é¢˜
- æ”¯æŒä¸­æ–‡å’Œè‹±æ–‡
- ç‚¹å‡»å‘é€æŒ‰é’®æˆ–æŒ‰å›è½¦é”®

### 2. è¯­éŸ³è¾“å…¥
- ç‚¹å‡»éº¦å…‹é£å›¾æ ‡å¼€å§‹å½•éŸ³
- è¯´å‡ºæ‚¨çš„é—®é¢˜
- å†æ¬¡ç‚¹å‡»åœæ­¢å½•éŸ³
- ç³»ç»Ÿä¼šè‡ªåŠ¨è½¬æ¢ä¸ºæ–‡å­—å¹¶å›å¤

### 3. æ–‡æ¡£ä¸Šä¼ 
- ç‚¹å‡»ä¸Šä¼ æŒ‰é’®
- é€‰æ‹©PDFæ–‡æ¡£ï¼ˆæœ€å¤§20MBï¼‰
- ç³»ç»Ÿä¼šåˆ†ææ–‡æ¡£å†…å®¹å¹¶æä¾›ç›¸å…³å»ºè®®

## æ”¯æŒçš„è¯é¢˜

1. **åŸºç¡€æ•™è‚²**: æ€§å¥åº·åŸºæœ¬æ¦‚å¿µå’Œé‡è¦æ€§
2. **å®‰å…¨é˜²æŠ¤**: æ€§å®‰å…¨æªæ–½å’Œä¿æŠ¤æ–¹æ³•
3. **é¿å­•çŸ¥è¯†**: å„ç§é¿å­•æ–¹æ³•å’Œè®¡åˆ’ç”Ÿè‚²
4. **ç”Ÿç†è§£å‰–**: ç”Ÿæ®–ç³»ç»Ÿå’Œç”Ÿç†å‘è‚²
5. **å…³ç³»å¥åº·**: å¥åº·çš„æ€§å…³ç³»å’Œæ²Ÿé€šæŠ€å·§
6. **ç–¾ç—…é¢„é˜²**: æ€§ä¼ æ’­ç–¾ç—…çš„é¢„é˜²å’Œæ£€æµ‹
7. **åŒæ„æ•™è‚²**: æ€§åŒæ„çš„é‡è¦æ€§å’Œè¾¹ç•Œè®¾å®š

## éšç§ä¿æŠ¤

âœ… æ‰€æœ‰å¯¹è¯å®Œå…¨æœ¬åœ°å¤„ç†
âœ… ä¸ä¿å­˜ä»»ä½•ä¸ªäººä¿¡æ¯
âœ… ä¸ä¸Šä¼ æ•°æ®åˆ°å¤–éƒ¨æœåŠ¡å™¨
âœ… æ”¯æŒå®Œå…¨ç¦»çº¿ä½¿ç”¨

## å¸¸è§é—®é¢˜

**Q: ç³»ç»Ÿæ”¯æŒå“ªäº›è¯­è¨€ï¼Ÿ**
A: æ”¯æŒç®€ä½“ä¸­æ–‡ï¼ˆæ™®é€šè¯å’Œæ²³å—æ–¹è¨€ï¼‰ä»¥åŠè‹±è¯­ã€‚

**Q: æˆ‘çš„éšç§å®‰å…¨å—ï¼Ÿ**
A: æ˜¯çš„ï¼Œæ‰€æœ‰å¤„ç†éƒ½åœ¨æ‚¨çš„è®¾å¤‡ä¸Šè¿›è¡Œï¼Œä¸ä¼šä¸Šä¼ ä»»ä½•æ•°æ®ã€‚

**Q: å¦‚ä½•è·å¾—æ›´å‡†ç¡®çš„å›ç­”ï¼Ÿ**
A: è¯·å°½é‡è¯¦ç»†æè¿°æ‚¨çš„é—®é¢˜ï¼Œä½¿ç”¨å…·ä½“çš„å…³é”®è¯ã€‚
```

---

## ğŸ¯ ä¸‹ä¸€æ­¥è¡ŒåŠ¨è®¡åˆ’

### ç«‹å³å¯æ‰§è¡Œçš„ä»»åŠ¡

1. **éªŒè¯å½“å‰ç³»ç»Ÿ** (30åˆ†é’Ÿ)
   ```bash
   # æ£€æŸ¥æ‰€æœ‰æœåŠ¡çŠ¶æ€
   make status
   
   # è¿è¡Œå®Œæ•´æµ‹è¯•
   make test
   ```

2. **å®Œå–„å‰ç«¯ç•Œé¢** (2-3å¤©)
   - å®ç°èŠå¤©ç•Œé¢ç»„ä»¶
   - æ·»åŠ è¯­éŸ³è¾“å…¥åŠŸèƒ½
   - é›†æˆæ–‡æ¡£ä¸Šä¼ 

3. **ä¼˜åŒ–ç”¨æˆ·ä½“éªŒ** (1-2å¤©)
   - æ·»åŠ åŠ è½½åŠ¨ç”»
   - æ”¹è¿›é”™è¯¯å¤„ç†
   - å®ç°å“åº”å¼è®¾è®¡

4. **å¤šè¯­è¨€ç•Œé¢** (1å¤©)
   - é…ç½®i18n
   - ç¿»è¯‘æ‰€æœ‰ç•Œé¢æ–‡æœ¬
   - æ·»åŠ è¯­è¨€åˆ‡æ¢å™¨

5. **æ€§èƒ½ä¼˜åŒ–** (1-2å¤©)
   - å®ç°å“åº”ç¼“å­˜
   - ä¼˜åŒ–æ¨¡å‹åŠ è½½
   - æ”¹è¿›å†…å­˜ç®¡ç†

### ä¸­æœŸç›®æ ‡ (1-2å‘¨)

1. **éƒ¨ç½²ä¼˜åŒ–**
   - é…ç½®ç”Ÿäº§ç¯å¢ƒ
   - è®¾ç½®ç›‘æ§å’Œæ—¥å¿—
   - å®ç°è‡ªåŠ¨å¤‡ä»½

2. **å†…å®¹è´¨é‡æå‡**
   - æ‰©å±•è®­ç»ƒæ•°æ®
   - æ”¹è¿›æç¤ºæ¨¡æ¿
   - åŠ å¼ºå®‰å…¨è¿‡æ»¤

3. **ç”¨æˆ·ä½“éªŒå¢å¼º**
   - æ·»åŠ ä½¿ç”¨æ•™ç¨‹
   - å®ç°ä¸ªæ€§åŒ–è®¾ç½®
   - ä¼˜åŒ–ç§»åŠ¨ç«¯ä½“éªŒ

### é•¿æœŸè§„åˆ’ (1-3ä¸ªæœˆ)

1. **åŠŸèƒ½æ‰©å±•**
   - æ·»åŠ å›¾ç‰‡è¯†åˆ«
   - å®ç°å¤šè½®å¯¹è¯è®°å¿†
   - å¼€å‘ç§»åŠ¨åº”ç”¨

2. **ç¤¾åŒºå»ºè®¾**
   - å¼€æºä»£ç å‘å¸ƒ
   - å»ºç«‹ç”¨æˆ·ç¤¾åŒº
   - æ”¶é›†åé¦ˆæ”¹è¿›

3. **å½±å“åŠ›æ‰©å¤§**
   - å­¦æœ¯è®ºæ–‡å‘è¡¨
   - ä¼šè®®æ¼”è®²åˆ†äº«
   - åˆä½œä¼™ä¼´æ‹“å±•

---

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚éœ€æŠ€æœ¯æ”¯æŒæˆ–æœ‰ä»»ä½•é—®é¢˜ï¼Œè¯·ï¼š

1. **æŸ¥çœ‹æ–‡æ¡£**: é¦–å…ˆæŸ¥é˜…é¡¹ç›®æ–‡æ¡£
2. **è¿è¡Œè¯Šæ–­**: ä½¿ç”¨ `make status` æ£€æŸ¥ç³»ç»ŸçŠ¶æ€
3. **æŸ¥çœ‹æ—¥å¿—**: æ£€æŸ¥ `logs/` ç›®å½•ä¸­çš„é”™è¯¯æ—¥å¿—
4. **æäº¤Issue**: åœ¨GitHubä¸Šæäº¤è¯¦ç»†çš„é—®é¢˜æŠ¥å‘Š

**é¡¹ç›®å·²ç»å…·å¤‡äº†å®Œæ•´çš„åŸºç¡€æ¶æ„ï¼Œç°åœ¨éœ€è¦çš„æ˜¯æŒ‰ç…§è¿™ä¸ªæŒ‡å—é€æ­¥å®Œå–„ç”¨æˆ·ç•Œé¢å’Œä½“éªŒä¼˜åŒ–ã€‚æ•´ä¸ªé¡¹ç›®å±•ç°äº†AIæŠ€æœ¯åœ¨æ•™è‚²é¢†åŸŸçš„è´Ÿè´£ä»»åº”ç”¨ï¼Œæ˜¯æŠ€æœ¯å‘å–„çš„ä¼˜ç§€èŒƒä¾‹ã€‚** 